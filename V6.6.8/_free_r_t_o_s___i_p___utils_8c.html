<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Plus-TCP: FreeRTOS_IP_Utils.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FreeRTOS-Plus-TCP<span id="projectnumber">&#160;V4.2.3</span>
   </div>
   <div id="projectbrief">FreeRTOS TCP/IP library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_free_r_t_o_s___i_p___utils_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS_IP_Utils.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements the basic functionality for the FreeRTOS+TCP network stack.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;FreeRTOS.h&quot;</code><br />
<code>#include &quot;task.h&quot;</code><br />
<code>#include &quot;queue.h&quot;</code><br />
<code>#include &quot;semphr.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Utils.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Timers.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Sockets.h&quot;</code><br />
<code>#include &quot;FreeRTOS_IP_Private.h&quot;</code><br />
<code>#include &quot;FreeRTOS_ARP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_UDP_IP.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DHCP.h&quot;</code><br />
<code>#include &quot;NetworkInterface.h&quot;</code><br />
<code>#include &quot;NetworkBufferManagement.h&quot;</code><br />
<code>#include &quot;FreeRTOS_DNS.h&quot;</code><br />
<code>#include &quot;FreeRTOS_Routing.h&quot;</code><br />
<code>#include &quot;FreeRTOS_ND.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionx_union32__t.html">xUnion32_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionx_union_ptr__t.html">xUnionPtr_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionu_int_ptr.html">uIntPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">uintptr_t is an unsigned integer type that is capable of storing a data pointer. Therefore it is safe to convert from a void pointer to a uintptr_t, using a union.  <a href="unionu_int_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8ef9c6533cd9f34111f6ff1e5843507d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a8ef9c6533cd9f34111f6ff1e5843507d">ipEXPECTED_EthernetHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 14 )</td></tr>
<tr class="separator:a8ef9c6533cd9f34111f6ff1e5843507d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13c9f74e9fe374fa459f8df1864dc72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#ac13c9f74e9fe374fa459f8df1864dc72">ipEXPECTED_ARPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 28 )</td></tr>
<tr class="separator:ac13c9f74e9fe374fa459f8df1864dc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43457a3ba4fd6f16a4d33394af459536"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a43457a3ba4fd6f16a4d33394af459536">ipEXPECTED_IPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 20 )</td></tr>
<tr class="separator:a43457a3ba4fd6f16a4d33394af459536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527470135bea5ef3d75f3c1206431584"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a527470135bea5ef3d75f3c1206431584">ipEXPECTED_IGMPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 8 )</td></tr>
<tr class="separator:a527470135bea5ef3d75f3c1206431584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc89907d7a25a7f795f2abcd9eb6aa6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a0dc89907d7a25a7f795f2abcd9eb6aa6">ipEXPECTED_ICMPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 8 )</td></tr>
<tr class="separator:a0dc89907d7a25a7f795f2abcd9eb6aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc551f421556711f0924201c04c9f82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a2cc551f421556711f0924201c04c9f82">ipEXPECTED_UDPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 8 )</td></tr>
<tr class="separator:a2cc551f421556711f0924201c04c9f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada34cd2dcc842a6c43cd9c85acd0ebc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#ada34cd2dcc842a6c43cd9c85acd0ebc2">ipEXPECTED_TCPHeader_t_SIZE</a>&#160;&#160;&#160;( ( size_t ) 20 )</td></tr>
<tr class="separator:ada34cd2dcc842a6c43cd9c85acd0ebc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af982816b81c2c41e4e50643993a23085"><td class="memItemLeft" align="right" valign="top"><a id="af982816b81c2c41e4e50643993a23085" name="af982816b81c2c41e4e50643993a23085"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ipINITIALISATION_RETRY_DELAY</b>&#160;&#160;&#160;( pdMS_TO_TICKS( 3000U ) )</td></tr>
<tr class="memdesc:af982816b81c2c41e4e50643993a23085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time delay between repeated attempts to initialise the network hardware. <br /></td></tr>
<tr class="separator:af982816b81c2c41e4e50643993a23085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985670bd700f08464870fb9fd42459f9"><td class="memItemLeft" align="right" valign="top"><a id="a985670bd700f08464870fb9fd42459f9" name="a985670bd700f08464870fb9fd42459f9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FREERTOS_MINIMUM_TCP_OFFSET</b>&#160;&#160;&#160;( 5U )</td></tr>
<tr class="memdesc:a985670bd700f08464870fb9fd42459f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum value of TCP offset value. <br /></td></tr>
<tr class="separator:a985670bd700f08464870fb9fd42459f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afb009e3856db87301868748c1732f74d"><td class="memItemLeft" align="right" valign="top">static NetworkBufferDescriptor_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#afb009e3856db87301868748c1732f74d">prvPacketBuffer_to_NetworkBuffer</a> (const void *pvBuffer, size_t uxOffset)</td></tr>
<tr class="memdesc:afb009e3856db87301868748c1732f74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the network buffer descriptor from the packet buffer.  <br /></td></tr>
<tr class="separator:afb009e3856db87301868748c1732f74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5273b63c9ff3e2d6bf9741bee6b8ff"><td class="memItemLeft" align="right" valign="top">static uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a3a5273b63c9ff3e2d6bf9741bee6b8ff">void_ptr_to_uintptr</a> (const void *pvPointer)</td></tr>
<tr class="memdesc:a3a5273b63c9ff3e2d6bf9741bee6b8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function: cast a pointer to a numeric value 'uintptr_t', using a union as defined here above.  <br /></td></tr>
<tr class="separator:a3a5273b63c9ff3e2d6bf9741bee6b8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d439f96ef27eb4b4bb8e44597c7e49f"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a8d439f96ef27eb4b4bb8e44597c7e49f">prvChecksumProtocolChecks</a> (size_t uxBufferLength, <a class="el" href="structstruct.html">struct</a> xPacketSummary *pxSet)</td></tr>
<tr class="memdesc:a8d439f96ef27eb4b4bb8e44597c7e49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get and check the specific lengths depending on the protocol ( TCP/UDP/ICMP/IGMP ).  <br /></td></tr>
<tr class="separator:a8d439f96ef27eb4b4bb8e44597c7e49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2b3a98ddc895f238b4dff631fc4551"><td class="memItemLeft" align="right" valign="top">static BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a4e2b3a98ddc895f238b4dff631fc4551">prvChecksumProtocolMTUCheck</a> (<a class="el" href="structstruct.html">struct</a> xPacketSummary *pxSet)</td></tr>
<tr class="memdesc:a4e2b3a98ddc895f238b4dff631fc4551"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if the packet doesn't get bigger than the value of MTU.  <br /></td></tr>
<tr class="separator:a4e2b3a98ddc895f238b4dff631fc4551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3b73b3773e67b932ceae1bb819a7a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a9c3b73b3773e67b932ceae1bb819a7a0">prvChecksumProtocolCalculate</a> (BaseType_t xOutgoingPacket, const uint8_t *pucEthernetBuffer, <a class="el" href="structstruct.html">struct</a> xPacketSummary *pxSet)</td></tr>
<tr class="memdesc:a9c3b73b3773e67b932ceae1bb819a7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the actual checksum calculations, both the pseudo header, and the payload.  <br /></td></tr>
<tr class="separator:a9c3b73b3773e67b932ceae1bb819a7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139d205a744822cca6f16f2e5aef1d40"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a139d205a744822cca6f16f2e5aef1d40">prvChecksumProtocolSetChecksum</a> (BaseType_t xOutgoingPacket, const uint8_t *pucEthernetBuffer, size_t uxBufferLength, const <a class="el" href="structstruct.html">struct</a> xPacketSummary *pxSet)</td></tr>
<tr class="memdesc:a139d205a744822cca6f16f2e5aef1d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">For outgoing packets, set the checksum in the packet, for incoming packets: show logging in case an error occurred.  <br /></td></tr>
<tr class="separator:a139d205a744822cca6f16f2e5aef1d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6029b5f8145e1d1f7a6682d97deb548c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a6029b5f8145e1d1f7a6682d97deb548c">prvSetChecksumInPacket</a> (const <a class="el" href="structstruct.html">struct</a> xPacketSummary *pxSet, uint16_t usChecksum)</td></tr>
<tr class="memdesc:a6029b5f8145e1d1f7a6682d97deb548c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set checksum in the packet.  <br /></td></tr>
<tr class="separator:a6029b5f8145e1d1f7a6682d97deb548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4fbd92cbabc7b66042531f71591cab"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#aae4fbd92cbabc7b66042531f71591cab">prvGetChecksumFromPacket</a> (const <a class="el" href="structstruct.html">struct</a> xPacketSummary *pxSet)</td></tr>
<tr class="memdesc:aae4fbd92cbabc7b66042531f71591cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get checksum from the packet summary.  <br /></td></tr>
<tr class="separator:aae4fbd92cbabc7b66042531f71591cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f26729c0f4b452e573da22ddb22f74"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a09f26729c0f4b452e573da22ddb22f74">xSendDHCPEvent</a> (<a class="el" href="structstruct.html">struct</a> xNetworkEndPoint *pxEndPoint)</td></tr>
<tr class="memdesc:a09f26729c0f4b452e573da22ddb22f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a DHCP event.  <br /></td></tr>
<tr class="separator:a09f26729c0f4b452e573da22ddb22f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d3f7986eb4951bfe67a9fd5506f6f0"><td class="memItemLeft" align="right" valign="top">NetworkBufferDescriptor_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#ae2d3f7986eb4951bfe67a9fd5506f6f0">pxDuplicateNetworkBufferWithDescriptor</a> (const NetworkBufferDescriptor_t *const pxNetworkBuffer, size_t uxNewLength)</td></tr>
<tr class="memdesc:ae2d3f7986eb4951bfe67a9fd5506f6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the given network buffer descriptor with a modified length.  <br /></td></tr>
<tr class="separator:ae2d3f7986eb4951bfe67a9fd5506f6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4a72619efccc84678a0ff7f1468a73"><td class="memItemLeft" align="right" valign="top">NetworkBufferDescriptor_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a6d4a72619efccc84678a0ff7f1468a73">pxUDPPayloadBuffer_to_NetworkBuffer</a> (const void *pvBuffer)</td></tr>
<tr class="memdesc:a6d4a72619efccc84678a0ff7f1468a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the network buffer from the UDP Payload buffer.  <br /></td></tr>
<tr class="separator:a6d4a72619efccc84678a0ff7f1468a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9844166e6474d5f406df1c57aa4da98f"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a9844166e6474d5f406df1c57aa4da98f">xIsCallingFromIPTask</a> (void)</td></tr>
<tr class="memdesc:a9844166e6474d5f406df1c57aa4da98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check whether the current context belongs to the IP-task.  <br /></td></tr>
<tr class="separator:a9844166e6474d5f406df1c57aa4da98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fceb7bed81db2c40bf5418ee888b262"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a9fceb7bed81db2c40bf5418ee888b262">prvProcessNetworkDownEvent</a> (<a class="el" href="structstruct.html">struct</a> xNetworkInterface *pxInterface)</td></tr>
<tr class="memdesc:a9fceb7bed81db2c40bf5418ee888b262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a 'Network down' event and complete required processing.  <br /></td></tr>
<tr class="separator:a9fceb7bed81db2c40bf5418ee888b262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b85ba0f6d16425960f9a9b5249dab9"><td class="memItemLeft" align="right" valign="top"><a id="a13b85ba0f6d16425960f9a9b5249dab9" name="a13b85ba0f6d16425960f9a9b5249dab9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vPreCheckConfigs</b> (void)</td></tr>
<tr class="memdesc:a13b85ba0f6d16425960f9a9b5249dab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the values of configuration options and assert on it. Also verify that the IP-task has not already been initialized. <br /></td></tr>
<tr class="separator:a13b85ba0f6d16425960f9a9b5249dab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee508999401118607a0d886a7d7d9a36"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#aee508999401118607a0d886a7d7d9a36">usGenerateProtocolChecksum</a> (uint8_t *pucEthernetBuffer, size_t uxBufferLength, BaseType_t xOutgoingPacket)</td></tr>
<tr class="memdesc:aee508999401118607a0d886a7d7d9a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate or check the protocol checksum of the data sent in the first parameter. At the same time, the length of the packet and the length of the different layers will be checked.  <br /></td></tr>
<tr class="separator:aee508999401118607a0d886a7d7d9a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97162cfd5b071ccee8fec503879a3e43"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a97162cfd5b071ccee8fec503879a3e43">usGenerateChecksum</a> (uint16_t usSum, const uint8_t *pucNextData, size_t uxByteCount)</td></tr>
<tr class="memdesc:a97162cfd5b071ccee8fec503879a3e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the 16-bit checksum of an array of bytes.  <br /></td></tr>
<tr class="separator:a97162cfd5b071ccee8fec503879a3e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e36f528b9268ef66b96bdb38442f257"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a8e36f528b9268ef66b96bdb38442f257">FreeRTOS_max_int32</a> (int32_t a, int32_t b)</td></tr>
<tr class="memdesc:a8e36f528b9268ef66b96bdb38442f257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest value of two int32's.  <br /></td></tr>
<tr class="separator:a8e36f528b9268ef66b96bdb38442f257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9116ad8c3051d8231bef15c56ec57791"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a9116ad8c3051d8231bef15c56ec57791">FreeRTOS_max_uint32</a> (uint32_t a, uint32_t b)</td></tr>
<tr class="memdesc:a9116ad8c3051d8231bef15c56ec57791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest value of two uint32_t's.  <br /></td></tr>
<tr class="separator:a9116ad8c3051d8231bef15c56ec57791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a76418ec84ced5006a825ec8b865e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#ac2a76418ec84ced5006a825ec8b865e3">FreeRTOS_max_size_t</a> (size_t a, size_t b)</td></tr>
<tr class="memdesc:ac2a76418ec84ced5006a825ec8b865e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest value of two size_t's.  <br /></td></tr>
<tr class="separator:ac2a76418ec84ced5006a825ec8b865e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4800536b39a0e736fbc91eeeb46ade00"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a4800536b39a0e736fbc91eeeb46ade00">FreeRTOS_min_int32</a> (int32_t a, int32_t b)</td></tr>
<tr class="memdesc:a4800536b39a0e736fbc91eeeb46ade00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lowest value of two int32_t's.  <br /></td></tr>
<tr class="separator:a4800536b39a0e736fbc91eeeb46ade00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7362b4fff227e86de3a660e4351546"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a2c7362b4fff227e86de3a660e4351546">FreeRTOS_min_uint32</a> (uint32_t a, uint32_t b)</td></tr>
<tr class="memdesc:a2c7362b4fff227e86de3a660e4351546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lowest value of two uint32_t's.  <br /></td></tr>
<tr class="separator:a2c7362b4fff227e86de3a660e4351546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad321c6de160a32ab0f4a53ba4b822be7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#ad321c6de160a32ab0f4a53ba4b822be7">FreeRTOS_min_size_t</a> (size_t a, size_t b)</td></tr>
<tr class="memdesc:ad321c6de160a32ab0f4a53ba4b822be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the lowest value of two size_t's.  <br /></td></tr>
<tr class="separator:ad321c6de160a32ab0f4a53ba4b822be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6602b34b70013ff9c74e93a69cddd129"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a6602b34b70013ff9c74e93a69cddd129">FreeRTOS_add_int32</a> (int32_t a, int32_t b)</td></tr>
<tr class="memdesc:a6602b34b70013ff9c74e93a69cddd129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a safe addition of two 32-bit integers, preventing overflow and underflow.  <br /></td></tr>
<tr class="separator:a6602b34b70013ff9c74e93a69cddd129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b7108bfe7179005085663dda60d50f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a24b7108bfe7179005085663dda60d50f">FreeRTOS_multiply_int32</a> (int32_t a, int32_t b)</td></tr>
<tr class="memdesc:a24b7108bfe7179005085663dda60d50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a safe multiplication of two 32-bit integers, preventing overflow and underflow.  <br /></td></tr>
<tr class="separator:a24b7108bfe7179005085663dda60d50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34489473730372ede66a0edb2df9b9be"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a34489473730372ede66a0edb2df9b9be">FreeRTOS_round_up</a> (uint32_t a, uint32_t d)</td></tr>
<tr class="memdesc:a34489473730372ede66a0edb2df9b9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round-up a number to a multiple of 'd'.  <br /></td></tr>
<tr class="separator:a34489473730372ede66a0edb2df9b9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13b7eb688e635270861d515a0bdb792"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#ab13b7eb688e635270861d515a0bdb792">FreeRTOS_round_down</a> (uint32_t a, uint32_t d)</td></tr>
<tr class="memdesc:ab13b7eb688e635270861d515a0bdb792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round-down a number to a multiple of 'd'.  <br /></td></tr>
<tr class="separator:ab13b7eb688e635270861d515a0bdb792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac672cbd6cb4f7131f7d69e3dc125f6c6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#ac672cbd6cb4f7131f7d69e3dc125f6c6">ulChar2u32</a> (const uint8_t *pucPtr)</td></tr>
<tr class="memdesc:ac672cbd6cb4f7131f7d69e3dc125f6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert character array (of size 4) to equivalent 32-bit value.  <br /></td></tr>
<tr class="separator:ac672cbd6cb4f7131f7d69e3dc125f6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af055f7ec0a669b54eb296f2e5f4eecb9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#af055f7ec0a669b54eb296f2e5f4eecb9">usChar2u16</a> (const uint8_t *pucPtr)</td></tr>
<tr class="memdesc:af055f7ec0a669b54eb296f2e5f4eecb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert character array (of size 2) to equivalent 16-bit value.  <br /></td></tr>
<tr class="separator:af055f7ec0a669b54eb296f2e5f4eecb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1184f91775b8f6b3191c117966059453"><td class="memItemLeft" align="right" valign="top">eDHCPState_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html#a1184f91775b8f6b3191c117966059453">eGetDHCPState</a> (const <a class="el" href="structstruct.html">struct</a> xNetworkEndPoint *pxEndPoint)</td></tr>
<tr class="memdesc:a1184f91775b8f6b3191c117966059453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state of a DHCP process.  <br /></td></tr>
<tr class="separator:a1184f91775b8f6b3191c117966059453"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the basic functionality for the FreeRTOS+TCP network stack. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8ef9c6533cd9f34111f6ff1e5843507d" name="a8ef9c6533cd9f34111f6ff1e5843507d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef9c6533cd9f34111f6ff1e5843507d">&#9670;&#160;</a></span>ipEXPECTED_EthernetHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_EthernetHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 14 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ethernet Header size in bytes. </p>

</div>
</div>
<a id="ac13c9f74e9fe374fa459f8df1864dc72" name="ac13c9f74e9fe374fa459f8df1864dc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13c9f74e9fe374fa459f8df1864dc72">&#9670;&#160;</a></span>ipEXPECTED_ARPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_ARPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 28 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ARP header size in bytes. </p>

</div>
</div>
<a id="a43457a3ba4fd6f16a4d33394af459536" name="a43457a3ba4fd6f16a4d33394af459536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43457a3ba4fd6f16a4d33394af459536">&#9670;&#160;</a></span>ipEXPECTED_IPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_IPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 20 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IP header size in bytes. </p>

</div>
</div>
<a id="a527470135bea5ef3d75f3c1206431584" name="a527470135bea5ef3d75f3c1206431584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527470135bea5ef3d75f3c1206431584">&#9670;&#160;</a></span>ipEXPECTED_IGMPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_IGMPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 8 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IGMP header size in bytes. </p>

</div>
</div>
<a id="a0dc89907d7a25a7f795f2abcd9eb6aa6" name="a0dc89907d7a25a7f795f2abcd9eb6aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc89907d7a25a7f795f2abcd9eb6aa6">&#9670;&#160;</a></span>ipEXPECTED_ICMPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_ICMPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 8 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ICMP header size in bytes. </p>

</div>
</div>
<a id="a2cc551f421556711f0924201c04c9f82" name="a2cc551f421556711f0924201c04c9f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc551f421556711f0924201c04c9f82">&#9670;&#160;</a></span>ipEXPECTED_UDPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_UDPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 8 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UDP header size in bytes. </p>

</div>
</div>
<a id="ada34cd2dcc842a6c43cd9c85acd0ebc2" name="ada34cd2dcc842a6c43cd9c85acd0ebc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada34cd2dcc842a6c43cd9c85acd0ebc2">&#9670;&#160;</a></span>ipEXPECTED_TCPHeader_t_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ipEXPECTED_TCPHeader_t_SIZE&#160;&#160;&#160;( ( size_t ) 20 )</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP header size in bytes. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afb009e3856db87301868748c1732f74d" name="afb009e3856db87301868748c1732f74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb009e3856db87301868748c1732f74d">&#9670;&#160;</a></span>prvPacketBuffer_to_NetworkBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static NetworkBufferDescriptor_t * prvPacketBuffer_to_NetworkBuffer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the network buffer descriptor from the packet buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>The pointer to packet buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxOffset</td><td>Additional offset (such as the packet length of UDP packet etc.).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The network buffer descriptor if the alignment is correct. Else a NULL is returned. </dd></dl>

</div>
</div>
<a id="a3a5273b63c9ff3e2d6bf9741bee6b8ff" name="a3a5273b63c9ff3e2d6bf9741bee6b8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5273b63c9ff3e2d6bf9741bee6b8ff">&#9670;&#160;</a></span>void_ptr_to_uintptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uintptr_t void_ptr_to_uintptr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvPointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function: cast a pointer to a numeric value 'uintptr_t', using a union as defined here above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pvPointer</td><td>A void pointer to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the void pointer as an unsigned number. </dd></dl>

</div>
</div>
<a id="a8d439f96ef27eb4b4bb8e44597c7e49f" name="a8d439f96ef27eb4b4bb8e44597c7e49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d439f96ef27eb4b4bb8e44597c7e49f">&#9670;&#160;</a></span>prvChecksumProtocolChecks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvChecksumProtocolChecks </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xPacketSummary *&#160;</td>
          <td class="paramname"><em>pxSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get and check the specific lengths depending on the protocol ( TCP/UDP/ICMP/IGMP ). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uxBufferLength</td><td>The number of bytes to be sent or received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSet</td><td>A struct describing this packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero in case of an error. </dd></dl>

</div>
</div>
<a id="a4e2b3a98ddc895f238b4dff631fc4551" name="a4e2b3a98ddc895f238b4dff631fc4551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2b3a98ddc895f238b4dff631fc4551">&#9670;&#160;</a></span>prvChecksumProtocolMTUCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static BaseType_t prvChecksumProtocolMTUCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xPacketSummary *&#160;</td>
          <td class="paramname"><em>pxSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See if the packet doesn't get bigger than the value of MTU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSet</td><td>A struct describing this packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero in case of an error. </dd></dl>

</div>
</div>
<a id="a9c3b73b3773e67b932ceae1bb819a7a0" name="a9c3b73b3773e67b932ceae1bb819a7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3b73b3773e67b932ceae1bb819a7a0">&#9670;&#160;</a></span>prvChecksumProtocolCalculate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvChecksumProtocolCalculate </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xOutgoingPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pucEthernetBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xPacketSummary *&#160;</td>
          <td class="paramname"><em>pxSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do the actual checksum calculations, both the pseudo header, and the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xOutgoingPacket</td><td>pdTRUE when the packet is to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pucEthernetBuffer</td><td>The buffer containing the packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSet</td><td>A struct describing this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a139d205a744822cca6f16f2e5aef1d40" name="a139d205a744822cca6f16f2e5aef1d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139d205a744822cca6f16f2e5aef1d40">&#9670;&#160;</a></span>prvChecksumProtocolSetChecksum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvChecksumProtocolSetChecksum </td>
          <td>(</td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xOutgoingPacket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pucEthernetBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> xPacketSummary *&#160;</td>
          <td class="paramname"><em>pxSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For outgoing packets, set the checksum in the packet, for incoming packets: show logging in case an error occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xOutgoingPacket</td><td>Non-zero if this is an outgoing packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pucEthernetBuffer</td><td>The buffer containing the packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxBufferLength</td><td>the total number of bytes received, or the number of bytes written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pxSet</td><td>A struct describing this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6029b5f8145e1d1f7a6682d97deb548c" name="a6029b5f8145e1d1f7a6682d97deb548c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6029b5f8145e1d1f7a6682d97deb548c">&#9670;&#160;</a></span>prvSetChecksumInPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void prvSetChecksumInPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> xPacketSummary *&#160;</td>
          <td class="paramname"><em>pxSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usChecksum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set checksum in the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxSet</td><td>Pointer to the packet summary that describes the packet, to which the checksum will be set.</td></tr>
    <tr><td class="paramname">usChecksum</td><td>Checksum value to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae4fbd92cbabc7b66042531f71591cab" name="aae4fbd92cbabc7b66042531f71591cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4fbd92cbabc7b66042531f71591cab">&#9670;&#160;</a></span>prvGetChecksumFromPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t prvGetChecksumFromPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> xPacketSummary *&#160;</td>
          <td class="paramname"><em>pxSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get checksum from the packet summary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxSet</td><td>Pointer to the packet summary that describes the packet, from which the checksum will be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Checksum value that is retrieved from pxSet. </dd></dl>

</div>
</div>
<a id="a09f26729c0f4b452e573da22ddb22f74" name="a09f26729c0f4b452e573da22ddb22f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f26729c0f4b452e573da22ddb22f74">&#9670;&#160;</a></span>xSendDHCPEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xSendDHCPEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xNetworkEndPoint *&#160;</td>
          <td class="paramname"><em>pxEndPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a DHCP event. </p>
<dl class="section return"><dt>Returns</dt><dd>pdPASS or pdFAIL, depending on whether <a class="el" href="_free_r_t_o_s___i_p_8c.html#a7190bc18fa344fe1fd79021a6db05f84" title="Send an event (in form of struct) to the IP task to be processed.">xSendEventStructToIPTask()</a> succeeded. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxEndPoint</td><td>The end-point that needs DHCP. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2d3f7986eb4951bfe67a9fd5506f6f0" name="ae2d3f7986eb4951bfe67a9fd5506f6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d3f7986eb4951bfe67a9fd5506f6f0">&#9670;&#160;</a></span>pxDuplicateNetworkBufferWithDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetworkBufferDescriptor_t * pxDuplicateNetworkBufferWithDescriptor </td>
          <td>(</td>
          <td class="paramtype">const NetworkBufferDescriptor_t *const&#160;</td>
          <td class="paramname"><em>pxNetworkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxNewLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate the given network buffer descriptor with a modified length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxNetworkBuffer</td><td>The network buffer to be duplicated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxNewLength</td><td>The length for the new buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If properly duplicated, then the duplicate network buffer or else, NULL. </dd></dl>

</div>
</div>
<a id="a6d4a72619efccc84678a0ff7f1468a73" name="a6d4a72619efccc84678a0ff7f1468a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4a72619efccc84678a0ff7f1468a73">&#9670;&#160;</a></span>pxUDPPayloadBuffer_to_NetworkBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetworkBufferDescriptor_t * pxUDPPayloadBuffer_to_NetworkBuffer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pvBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the network buffer from the UDP Payload buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pvBuffer</td><td>Pointer to the UDP payload buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The network buffer if the alignment is correct. Else a NULL is returned. </dd></dl>

</div>
</div>
<a id="a9844166e6474d5f406df1c57aa4da98f" name="a9844166e6474d5f406df1c57aa4da98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9844166e6474d5f406df1c57aa4da98f">&#9670;&#160;</a></span>xIsCallingFromIPTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t xIsCallingFromIPTask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check whether the current context belongs to the IP-task. </p>
<dl class="section return"><dt>Returns</dt><dd>If the current context belongs to the IP-task, then pdTRUE is returned. Else pdFALSE is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Very important: the IP-task is not allowed to call its own API's, because it would easily get into a dead-lock. </dd></dl>

</div>
</div>
<a id="a9fceb7bed81db2c40bf5418ee888b262" name="a9fceb7bed81db2c40bf5418ee888b262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fceb7bed81db2c40bf5418ee888b262">&#9670;&#160;</a></span>prvProcessNetworkDownEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prvProcessNetworkDownEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstruct.html">struct</a> xNetworkInterface *&#160;</td>
          <td class="paramname"><em>pxInterface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process a 'Network down' event and complete required processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pxInterface</td><td>The interface that goes down. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee508999401118607a0d886a7d7d9a36" name="aee508999401118607a0d886a7d7d9a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee508999401118607a0d886a7d7d9a36">&#9670;&#160;</a></span>usGenerateProtocolChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t usGenerateProtocolChecksum </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucEthernetBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxBufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseType_t&#160;</td>
          <td class="paramname"><em>xOutgoingPacket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate or check the protocol checksum of the data sent in the first parameter. At the same time, the length of the packet and the length of the different layers will be checked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucEthernetBuffer</td><td>The Ethernet buffer for which the checksum is to be calculated or checked. 'pucEthernetBuffer' is now non-const because the function will set the checksum fields, in case 'xOutgoingPacket' is pdTRUE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxBufferLength</td><td>the total number of bytes received, or the number of bytes written in the packet buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xOutgoingPacket</td><td>Whether this is an outgoing packet or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>When xOutgoingPacket is false: the error code can be either: ipINVALID_LENGTH, ipUNHANDLED_PROTOCOL, ipWRONG_CRC, or ipCORRECT_CRC. When xOutgoingPacket is true: either ipINVALID_LENGTH, ipUNHANDLED_PROTOCOL, or ipCORRECT_CRC. </dd></dl>

</div>
</div>
<a id="a97162cfd5b071ccee8fec503879a3e43" name="a97162cfd5b071ccee8fec503879a3e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97162cfd5b071ccee8fec503879a3e43">&#9670;&#160;</a></span>usGenerateChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t usGenerateChecksum </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pucNextData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>uxByteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the 16-bit checksum of an array of bytes. </p>
<p>This method generates a checksum for a given IPv4 header, per RFC791 (page 14). The checksum algorithm is described as: "[T]he 16 bit one's complement of the one's complement sum of all 16 bit words in the
  header.  For purposes of computing the checksum, the value of the checksum field is zero."</p>
<p>In a nutshell, that means that each 16-bit 'word' must be summed, after which the number of 'carries' (overflows) is added to the result. If that addition produces an overflow, that 'carry' must also be added to the final result. The final checksum should be the bitwise 'not' (ones-complement) of the result if the packet is meant to be transmitted, but this method simply returns the raw value, probably because when a packet is received, the checksum is verified by checking that ((received &amp; calculated) == 0) without applying a bitwise 'not' to the 'calculated' checksum.</p>
<p>This logic is optimized for microcontrollers which have limited resources, so the logic looks odd. It iterates over the full range of 16-bit words, but it does so by processing several 32-bit words at once whenever possible. Its first step is to align the memory pointer to a 32-bit boundary, after which it runs a fast loop to process multiple 32-bit words at once and adding their 'carries'. Finally, it finishes up by processing any remaining 16-bit words, and adding up all of the 'carries'. With 32-bit arithmetic, the number of 16-bit 'carries' produced by sequential additions can be found by looking at the 16 most-significant bits of the 32-bit integer, since a 32-bit int will continue counting up instead of overflowing after 16 bits. That is why the actual checksum calculations look like: union.u32 = ( uint32_t ) union.u16[ 0 ] + union.u16[ 1 ];</p>
<p>Arguments: ulSum: This argument provides a value to initialise the progressive summation of the header's values to. It is often 0, but protocols like TCP or UDP can have pseudo-header fields which need to be included in the checksum. pucNextData: This argument contains the address of the first byte which this method should process. The method's memory iterator is initialised to this value. uxDataLengthBytes: This argument contains the number of bytes that this method should process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">usSum</td><td>The initial sum, obtained from earlier data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pucNextData</td><td>The actual data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uxByteCount</td><td>The number of bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16-bit one's complement of the one's complement sum of all 16-bit words in the header </dd></dl>

</div>
</div>
<a id="a8e36f528b9268ef66b96bdb38442f257" name="a8e36f528b9268ef66b96bdb38442f257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e36f528b9268ef66b96bdb38442f257">&#9670;&#160;</a></span>FreeRTOS_max_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FreeRTOS_max_int32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the highest value of two int32's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest of the two values. </dd></dl>

</div>
</div>
<a id="a9116ad8c3051d8231bef15c56ec57791" name="a9116ad8c3051d8231bef15c56ec57791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9116ad8c3051d8231bef15c56ec57791">&#9670;&#160;</a></span>FreeRTOS_max_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_max_uint32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the highest value of two uint32_t's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest of the two values. </dd></dl>

</div>
</div>
<a id="ac2a76418ec84ced5006a825ec8b865e3" name="ac2a76418ec84ced5006a825ec8b865e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a76418ec84ced5006a825ec8b865e3">&#9670;&#160;</a></span>FreeRTOS_max_size_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS_max_size_t </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the highest value of two size_t's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The highest of the two values. </dd></dl>

</div>
</div>
<a id="a4800536b39a0e736fbc91eeeb46ade00" name="a4800536b39a0e736fbc91eeeb46ade00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4800536b39a0e736fbc91eeeb46ade00">&#9670;&#160;</a></span>FreeRTOS_min_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FreeRTOS_min_int32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lowest value of two int32_t's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowest of the two values. </dd></dl>

</div>
</div>
<a id="a2c7362b4fff227e86de3a660e4351546" name="a2c7362b4fff227e86de3a660e4351546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7362b4fff227e86de3a660e4351546">&#9670;&#160;</a></span>FreeRTOS_min_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_min_uint32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lowest value of two uint32_t's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowest of the two values. </dd></dl>

</div>
</div>
<a id="ad321c6de160a32ab0f4a53ba4b822be7" name="ad321c6de160a32ab0f4a53ba4b822be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad321c6de160a32ab0f4a53ba4b822be7">&#9670;&#160;</a></span>FreeRTOS_min_size_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS_min_size_t </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the lowest value of two size_t's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowest of the two values. </dd></dl>

</div>
</div>
<a id="a6602b34b70013ff9c74e93a69cddd129" name="a6602b34b70013ff9c74e93a69cddd129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6602b34b70013ff9c74e93a69cddd129">&#9670;&#160;</a></span>FreeRTOS_add_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FreeRTOS_add_int32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a safe addition of two 32-bit integers, preventing overflow and underflow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of a + b if no overflow/underflow occurs, or INT32_MAX/INT32_MIN if overflow/underflow would occur. </dd></dl>

</div>
</div>
<a id="a24b7108bfe7179005085663dda60d50f" name="a24b7108bfe7179005085663dda60d50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b7108bfe7179005085663dda60d50f">&#9670;&#160;</a></span>FreeRTOS_multiply_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FreeRTOS_multiply_int32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a safe multiplication of two 32-bit integers, preventing overflow and underflow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of a * b if no overflow occurs, or ipINT32_MAX_VALUE if an overflow would occur. </dd></dl>

</div>
</div>
<a id="a34489473730372ede66a0edb2df9b9be" name="a34489473730372ede66a0edb2df9b9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34489473730372ede66a0edb2df9b9be">&#9670;&#160;</a></span>FreeRTOS_round_up()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_round_up </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round-up a number to a multiple of 'd'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>the second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A multiple of d. </dd></dl>

</div>
</div>
<a id="ab13b7eb688e635270861d515a0bdb792" name="ab13b7eb688e635270861d515a0bdb792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13b7eb688e635270861d515a0bdb792">&#9670;&#160;</a></span>FreeRTOS_round_down()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FreeRTOS_round_down </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round-down a number to a multiple of 'd'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the first value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>the second value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A multiple of d. </dd></dl>

</div>
</div>
<a id="ac672cbd6cb4f7131f7d69e3dc125f6c6" name="ac672cbd6cb4f7131f7d69e3dc125f6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac672cbd6cb4f7131f7d69e3dc125f6c6">&#9670;&#160;</a></span>ulChar2u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ulChar2u32 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pucPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert character array (of size 4) to equivalent 32-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucPtr</td><td>The character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32-bit equivalent value extracted from the character array.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Going by MISRA rules, these utility functions should not be defined if they are not being used anywhere. But their use depends on the application and hence these functions are defined unconditionally. </dd></dl>

</div>
</div>
<a id="af055f7ec0a669b54eb296f2e5f4eecb9" name="af055f7ec0a669b54eb296f2e5f4eecb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af055f7ec0a669b54eb296f2e5f4eecb9">&#9670;&#160;</a></span>usChar2u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t usChar2u16 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pucPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert character array (of size 2) to equivalent 16-bit value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucPtr</td><td>The character array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>16-bit equivalent value extracted from the character array.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Going by MISRA rules, these utility functions should not be defined if they are not being used anywhere. But their use depends on the application and hence these functions are defined unconditionally. </dd></dl>

</div>
</div>
<a id="a1184f91775b8f6b3191c117966059453" name="a1184f91775b8f6b3191c117966059453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1184f91775b8f6b3191c117966059453">&#9670;&#160;</a></span>eGetDHCPState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">eDHCPState_t eGetDHCPState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstruct.html">struct</a> xNetworkEndPoint *&#160;</td>
          <td class="paramname"><em>pxEndPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current state of a DHCP process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pxEndPoint</td><td>the end-point which is going through the DHCP process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="_free_r_t_o_s___i_p___utils_8c.html">FreeRTOS_IP_Utils.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
